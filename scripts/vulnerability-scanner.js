#!/usr/bin/env node
/**
 * CheatCal Security Vulnerability Scanner
 * 
 * Comprehensive security analysis for CheatCal's controversial monitoring
 * features, ensuring privacy compliance and secure implementation.
 * 
 * @version 1.0.0 (Security Scanner Release)
 * @author CheatCal Security Team
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

// ASCII Security Architecture
const SECURITY_SCANNING_ARCHITECTURE = `
CHEATCAL SECURITY VULNERABILITY SCANNER
═══════════════════════════════════════════════════════════════

COMPREHENSIVE SECURITY ANALYSIS:
┌─────────────────────────────────────────────────────────────┐
│                 CONTROVERSIAL FEATURE SECURITY              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ 🔒 PRIVACY COMPLIANCE VALIDATION:                          │
│ ├── Monitoring feature consent mechanisms                  │
│ ├── Data collection transparency                           │
│ ├── User control and opt-out capabilities                 │
│ └── Data minimization and local processing                │
│                                                             │
│ 🛡️ SECURITY VULNERABILITY SCANNING:                       │
│ ├── Dependency vulnerability analysis                     │
│ ├── Code injection prevention                             │
│ ├── Authentication and authorization review               │
│ └── Data encryption and protection validation             │
│                                                             │
│ ⚠️ CONTROVERSY SAFETY CHECKS:                             │
│ ├── No secret credential exposure                         │
│ ├── Monitoring features properly disclosed                │
│ ├── User consent properly implemented                     │
│ └── Privacy policy compliance verification               │
└─────────────────────────────────────────────────────────────┘
`;

class VulnerabilityScanner {
  constructor() {
    this.projectRoot = process.cwd();
    this.vulnerabilities = [];
    this.privacyIssues = [];
    this.securityIssues = [];
    
    console.log('🛡️ CheatCal Security Vulnerability Scanner initializing...');
    console.log(SECURITY_SCANNING_ARCHITECTURE);
  }

  async scan() {
    console.log('🔍 Starting comprehensive security scan...\n');

    try {
      await this.scanDependencyVulnerabilities();
      await this.scanCodeSecurity();
      await this.scanPrivacyCompliance();
      await this.scanControversialFeatures();

      this.generateSecurityReport();

      const criticalIssues = this.vulnerabilities.filter(v => v.severity === 'critical');
      if (criticalIssues.length > 0) {
        console.log('\n🚨 CRITICAL security issues found!');
        process.exit(1);
      }

      console.log('\n✅ Security vulnerability scan complete!');
      return {
        vulnerabilities: this.vulnerabilities,
        privacyIssues: this.privacyIssues,
        securityIssues: this.securityIssues
      };

    } catch (error) {
      console.error('\n💥 Security scan failed:', error.message);
      throw error;
    }
  }

  /**
   * Scan Dependencies for Vulnerabilities
   */
  async scanDependencyVulnerabilities() {
    console.log('📦 Scanning dependency vulnerabilities...');

    try {
      const auditOutput = execSync('pnpm audit --json', { 
        encoding: 'utf8',
        cwd: this.projectRoot 
      });
      
      const audit = JSON.parse(auditOutput);
      
      if (audit.vulnerabilities) {
        Object.keys(audit.vulnerabilities).forEach(pkg => {
          const vuln = audit.vulnerabilities[pkg];
          this.vulnerabilities.push({
            type: 'dependency',
            package: pkg,
            severity: vuln.severity,
            title: vuln.title || 'Unknown vulnerability',
            fixAvailable: vuln.fixAvailable || false,
            patched: vuln.patched || false
          });
        });
      }

      console.log(`   Found ${this.vulnerabilities.length} dependency vulnerabilities`);

    } catch (error) {
      console.warn('   Dependency audit failed:', error.message);
    }
  }

  /**
   * Scan Code for Security Issues
   */
  async scanCodeSecurity() {
    console.log('🔍 Scanning code for security issues...');

    const securityPatterns = [
      {
        pattern: /process\.env\.[A-Z_]+/g,
        type: 'environment_variable_exposure',
        severity: 'medium',
        description: 'Environment variable usage detected'
      },
      {
        pattern: /console\.log.*password|console\.log.*secret|console\.log.*token/gi,
        type: 'credential_logging',
        severity: 'critical',
        description: 'Potential credential logging detected'
      },
      {
        pattern: /localStorage\.setItem.*password|localStorage\.setItem.*token/gi,
        type: 'credential_storage',
        severity: 'high',
        description: 'Sensitive data in localStorage detected'
      },
      {
        pattern: /eval\(|Function\(.*\)|new Function/gi,
        type: 'code_injection_risk',
        severity: 'high', 
        description: 'Dynamic code execution detected'
      },
      {
        pattern: /dangerouslySetInnerHTML/gi,
        type: 'xss_risk',
        severity: 'medium',
        description: 'Potential XSS vulnerability'
      }
    ];

    const files = this.getSourceFiles();
    
    for (const file of files) {
      const content = fs.readFileSync(file, 'utf8');
      
      securityPatterns.forEach(({ pattern, type, severity, description }) => {
        const matches = Array.from(content.matchAll(pattern));
        
        matches.forEach(match => {
          this.securityIssues.push({
            file: path.relative(this.projectRoot, file),
            type,
            severity,
            description,
            line: content.substring(0, match.index).split('\n').length,
            content: match[0],
            autoFixable: type !== 'credential_logging'
          });
        });
      });
    }

    console.log(`   Found ${this.securityIssues.length} potential security issues`);
  }

  /**
   * Scan Privacy Compliance for Controversial Features
   */
  async scanPrivacyCompliance() {
    console.log('👁️ Scanning privacy compliance for controversial features...');

    const privacyPatterns = [
      {
        pattern: /screen.*capture|screenCapture|getDisplayMedia/gi,
        feature: 'screen_monitoring',
        compliance_required: ['user_consent', 'transparency', 'opt_out']
      },
      {
        pattern: /microphone|getUserMedia.*audio|audio.*analysis/gi,
        feature: 'audio_monitoring',
        compliance_required: ['explicit_consent', 'recording_notice', 'data_retention_policy']
      },
      {
        pattern: /email.*monitoring|email.*analysis|gmail.*api/gi,
        feature: 'email_analysis',
        compliance_required: ['scope_limitation', 'user_control', 'data_minimization']
      },
      {
        pattern: /calendar.*sync|calendar.*analysis/gi,
        feature: 'calendar_integration',
        compliance_required: ['data_purpose_limitation', 'user_consent']
      }
    ];

    const files = this.getSourceFiles();
    
    for (const file of files) {
      const content = fs.readFileSync(file, 'utf8');
      
      privacyPatterns.forEach(({ pattern, feature, compliance_required }) => {
        const matches = Array.from(content.matchAll(pattern));
        
        if (matches.length > 0) {
          this.privacyIssues.push({
            file: path.relative(this.projectRoot, file),
            feature,
            instances: matches.length,
            compliance_required,
            consent_mechanisms_detected: this.detectConsentMechanisms(content),
            transparency_provided: this.detectTransparencyMechanisms(content)
          });
        }
      });
    }

    console.log(`   Found ${this.privacyIssues.length} privacy-sensitive features`);
  }

  /**
   * Scan Controversial Features Implementation
   */
  async scanControversialFeatures() {
    console.log('💀 Scanning controversial feature implementations...');

    const controversialFeatures = [
      {
        file: 'electron/CheatCalSystemOverlay.ts',
        feature: 'system_overlay',
        requirements: ['stealth_mode_disclosure', 'performance_monitoring', 'user_control']
      },
      {
        file: 'lib/computer-vision/EnhancedCheatCalVision.ts', 
        feature: 'computer_vision',
        requirements: ['accuracy_claims', 'privacy_protection', 'local_processing']
      },
      {
        file: 'lib/ai/CheatCalContextEngine.ts',
        feature: 'context_fusion',
        requirements: ['multi_modal_consent', 'data_fusion_transparency', 'user_benefits']
      }
    ];

    controversialFeatures.forEach(({ file, feature, requirements }) => {
      const filePath = path.join(this.projectRoot, file);
      
      if (fs.existsSync(filePath)) {
        const content = fs.readFileSync(filePath, 'utf8');
        
        const implementationQuality = this.analyzeControversialImplementation(
          content, 
          feature, 
          requirements
        );
        
        this.privacyIssues.push({
          file,
          feature,
          implementation_quality: implementationQuality,
          meets_requirements: implementationQuality.score >= 80,
          missing_requirements: implementationQuality.missing
        });
      } else {
        this.privacyIssues.push({
          file,
          feature,
          issue: 'File not found - controversial feature not implemented',
          severity: 'info'
        });
      }
    });

    console.log(`   Analyzed ${controversialFeatures.length} controversial features`);
  }

  // Helper Methods

  getSourceFiles() {
    return [
      ...this.globFiles('app/**/*.{ts,tsx}'),
      ...this.globFiles('components/**/*.{ts,tsx}'),
      ...this.globFiles('lib/**/*.{ts,tsx}'),
      ...this.globFiles('hooks/**/*.{ts,tsx}'),
      ...this.globFiles('electron/**/*.{ts,tsx}')
    ].filter(file => !file.includes('node_modules'));
  }

  globFiles(pattern) {
    try {
      return require('glob').sync(pattern, { cwd: this.projectRoot })
        .map(f => path.join(this.projectRoot, f));
    } catch (error) {
      return [];
    }
  }

  detectConsentMechanisms(content) {
    const consentPatterns = [
      /consent|permission|authorize|accept/gi,
      /user.*control|opt.*out|disable/gi,
      /privacy.*settings|monitoring.*settings/gi
    ];

    return consentPatterns.some(pattern => pattern.test(content));
  }

  detectTransparencyMechanisms(content) {
    const transparencyPatterns = [
      /privacy.*notice|disclosure|transparency/gi,
      /what.*we.*collect|how.*we.*use/gi,
      /monitoring.*active|watching|analyzing/gi
    ];

    return transparencyPatterns.some(pattern => pattern.test(content));
  }

  analyzeControversialImplementation(content, feature, requirements) {
    let score = 0;
    const missing = [];
    const total = requirements.length;

    requirements.forEach(req => {
      const implemented = this.checkRequirementImplementation(content, req);
      if (implemented) {
        score += (100 / total);
      } else {
        missing.push(req);
      }
    });

    return { score: Math.round(score), missing, total };
  }

  checkRequirementImplementation(content, requirement) {
    const requirementPatterns = {
      stealth_mode_disclosure: /stealth.*mode|invisible.*operation|transparency/gi,
      performance_monitoring: /performance.*monitor|fps.*target|cpu.*usage/gi,
      user_control: /user.*control|settings|disable.*monitoring/gi,
      accuracy_claims: /accuracy|confidence.*score|\d+%.*accuracy/gi,
      privacy_protection: /privacy.*protection|local.*processing|minimal.*cloud/gi,
      local_processing: /local.*processing|client.*side|browser.*only/gi,
      multi_modal_consent: /multi.*modal|visual.*audio.*calendar/gi,
      data_fusion_transparency: /data.*fusion|context.*fusion|comprehensive.*understanding/gi,
      user_benefits: /value.*creation|money.*impact|productivity.*optimization/gi
    };

    const pattern = requirementPatterns[requirement];
    return pattern ? pattern.test(content) : false;
  }

  /**
   * Generate Security Report
   */
  generateSecurityReport() {
    console.log('\n📋 CheatCal Security Scan Report');
    console.log('=' .repeat(50));

    // Vulnerability Summary
    console.log('\n🔒 Security Vulnerabilities:');
    const critical = this.vulnerabilities.filter(v => v.severity === 'critical');
    const high = this.vulnerabilities.filter(v => v.severity === 'high');
    const medium = this.vulnerabilities.filter(v => v.severity === 'medium');
    
    console.log(`   Critical: ${critical.length}`);
    console.log(`   High: ${high.length}`);
    console.log(`   Medium: ${medium.length}`);

    if (critical.length > 0) {
      console.log('\n🚨 Critical Vulnerabilities:');
      critical.forEach(vuln => {
        console.log(`   • ${vuln.package || vuln.file}: ${vuln.title || vuln.description}`);
      });
    }

    // Privacy Compliance Summary
    console.log('\n👁️ Privacy Compliance:');
    const privacyFeatures = this.privacyIssues.length;
    const compliantFeatures = this.privacyIssues.filter(p => p.meets_requirements !== false).length;
    
    console.log(`   Features analyzed: ${privacyFeatures}`);
    console.log(`   Compliance rate: ${privacyFeatures > 0 ? Math.round((compliantFeatures / privacyFeatures) * 100) : 100}%`);

    // Security Issues Summary
    console.log('\n🔍 Code Security Issues:');
    console.log(`   Total issues: ${this.securityIssues.length}`);
    const autoFixable = this.securityIssues.filter(i => i.autoFixable);
    console.log(`   Auto-fixable: ${autoFixable.length}`);

    // Recommendations
    console.log('\n🎯 Security Recommendations:');
    if (critical.length > 0) {
      console.log('   • URGENT: Address critical vulnerabilities immediately');
    }
    if (this.privacyIssues.length > 0) {
      console.log('   • Review privacy compliance for controversial features');
    }
    if (autoFixable.length > 0) {
      console.log('   • Run automated security fixes for code issues');
    }
    
    console.log('   • Regular security audits for controversial monitoring features');
    console.log('   • Privacy policy updates for new monitoring capabilities');
    console.log('   • User consent mechanisms for surveillance features');
  }
}

// CLI Usage
if (require.main === module) {
  const scanner = new VulnerabilityScanner();
  scanner.scan().catch(error => {
    console.error('💥 Security scan failed:', error);
    process.exit(1);
  });
}

module.exports = VulnerabilityScanner;